{"name":"Linq.extras","tagline":"A set of extension methods to complement the ones from System.Linq.Enumerable","body":"Linq.Extras\r\n===========\r\n\r\nA set of extension and helper methods to complement the ones from `System.Linq.Enumerable`.\r\n\r\nSome of these methods are just shortcuts for common Linq operations (e.g. `Append`, `IsNullOrEmpty`), or improvements to\r\nexisting Linq methods (e.g. specify default value for `FirstOrDefault`, specify comparer for `Max`). Others do more\r\ncomplex things that have no equivalent in standard Linq (`RankBy`, `DistinctUntilChanged`).\r\n\r\nHere are some methods of interest:\r\n\r\n### `DistinctBy`, `IntersectBy`, `UnionBy`, `ExceptBy`, `SequenceEqualBy`\r\n\r\nSame as `Distinct`, `Intersect`, `Union`, `Except`, `SequenceEqual`, but allow you to specify a key for equality comparison.\r\n\r\n```csharp\r\nvar result = items.DistinctBy(i => i.Name);\r\n```\r\n\r\n### `DistinctUntilChanged`\r\n\r\nReturns a sequence with distinct contiguous items (i.e. removes contiguous duplicates).\r\n\r\n```csharp\r\nvar input = new[] { 1, 1, 1, 2, 3, 3, 1, 3, 2, 2, 1 };\r\nvar result = input.DistinctUntilChanged(); // 1, 2, 3, 1, 3, 2, 1\r\n```\r\n\r\nThis is the enumerable equivalent of the [`Observable.DistinctUntilChanged`](http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.distinctuntilchanged%28v=vs.103%29.aspx) method from Rx.\r\n\r\n### `MinBy`, `MaxBy`\r\n\r\nReturn the item of a sequence that has the min or max value for the specified key.\r\n\r\n```csharp\r\nvar winner = players.MaxBy(p => p.Score);\r\nConsole.WriteLine(\"The winner is {0} with {1} points!\", p.Name, p.Score);\r\n```\r\n\r\nUnlike the well known approach of sorting the list and taking the first item, this method doesn't need sorting and operates in O(n).\r\n\r\n### `RankBy`, `DenseRankBy`\r\n\r\nThese methods associate a rank with each item of a collection, based on the specified key. The difference between the two is the same as between the `RANK` and `DENSE_RANK` functions in SQL:\r\n`RankBy` leaves \"holes\" in the ranks if some items are equal, while `DenseRankBy` does not.\r\n\r\nThis code:\r\n\r\n```csharp\r\nvar ranking = players.RankByDescending(player => player.Score, (player, rank) => string.Format(\"{0}. {1} ({2})\", rank, player.Name, player.Score));\r\n```\r\n\r\nProduces the following results\r\n\r\n```\r\n1. Joe (42)\r\n2. Liz (23)\r\n2. Ben (23)\r\n4. Ann (16)\r\n5. Bob (15)\r\n```\r\n\r\n### `LeftOuterJoin`, `RightOuterJoin`, `FullOuterJoin`\r\n\r\nAs the names imply.\r\n\r\nThe first two are for those who always forget how to do an outer join with Linq ;).\r\n\r\n`FullOuterJoin` fills a gap, though, since there is no built-in way to do it with Linq.\r\n\r\n```csharp\r\nvar result = left.OuterJoin(right, x => x.Id, y => y.Id, (id, x, y) => new { x, y });\r\n```\r\n\r\n### `ToHierarchy`\r\n\r\nTransform a flat sequence of items into a hierarchy. Each node is of type `INode<T>` and exposes its children and parent.\r\n\r\n```csharp\r\nvar roots = items.ToHierarchy(i => i.Id, i => i.ParentId);\r\n```\r\n\r\n### `Flatten`\r\n\r\nTransform a hierarchy of objects to a flat sequence.\r\n\r\n```csharp\r\nvar flat = roots.Flatten(node => node.Children, TreeTraversalMode.DepthFirst);\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}